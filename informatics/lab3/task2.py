import re
import json
# обозначаем число для минмального значения слов в промежутке
fromTaskNumberStart = 0

# обозначаем число для минмального значения слов в промежутке
fromTaskNumberEnd = 4

# наш массив найденных вхождений
k = []

string = input("Введите ваше сообщение: ")
# фор для применения паттерна к каждому набору  слов между ВТ ИТИМО до нашей fromTaskNumberEnd(невозможно сделать без фор, так как регулярные выражения
# работают как тарафарет, нашли вхождение(причём самое большое по длине)отбросили, пошли дальше, не будут рассматриваться случаи внутри этого вхождения,
# в теории можно рассмотреть использование finditer для этого, но тогда мы всё равно будем пользоваться циклом для прогона каждой группы)
for i in range(fromTaskNumberStart, fromTaskNumberEnd+1):
    kkk = '\\bВТ\\b(?: +[^-\w]*[-\w]{{0,}}[^-\w]*){{{0}}} \\bИТМО\\b'.format(str(i))
    k.extend(re.findall(kkk, string))

my_json = {}
my_answers = ['']

if len(k) != 0:
    my_answers = k
my_json["answers"] = my_answers
for i in k:
    print(i)

with open('result.json', 'w', encoding="utf-8") as file:
    dumped_json = json.dumps(my_json, ensure_ascii=False)
    file.write(dumped_json)
# доказательство невозможности некостыльного решения = невозможность трафарета возвращаться назад, можно пофирксить только двойным перебором вхождений
# от каждого ВТ к каждому ИТМО -> накладывание к каждому такому случаю наш трафарет, но единственный момент останется в разрешении с ситуацией повторов+
# надо будет решить как сплитить так, чтобы понимать идёт ли дальше после итмо что-то и перед ВТ
# и красиво вывести